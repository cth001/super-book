# 超级账本计划
属于自己的"超级账本仓库",因为以前记笔记是分了很多文件去记录的,这就导致无法使用全文检索,去找到我记录的知识点,所以准备尝试,将所有笔记代码记录在一起,可以快速定位到笔记内容,从而解决问题!

本次账本记录与后端一切相关知识!

切记因为笔记可能会变得十分臃肿,所以一定要分好类!分类原则秉承着,宁愿多分,也不要少分的原则。一级标题与二级标题都属于大分类,按照分类标准来写,三级分类属于小标题,按照时间来写。三级标题格式为 内容 2019年8月23日 12:07:19这种形式

# Java基础语法相关

> 本分类包含内容:
>
> 1. JDK内置api(如时间localdate api)
> 2. java基础语法(如lambda)

# 编程思路

> 1. 实现特定功能的思路(比如rbac模型,用户密码找回,分布式系统中session的使用等等)
> 2. 对一些词汇的理解
> 3. 一句话概括某项变成事物
> 4. 为什么会出现某种编程现象的理解(比如为什么要使用分布式,读写分离)

#服务层

##JavaEE相关

> 1. servlet相关知识(如原生拦截器实现跨域访问,session相关知识等) 

##spring相关

> 1. 这里主要是spring框架相关知识(如aop 如何在springboot上使用等)

##SpringMVC相关

##SpringBoot相关

> 1. springboot相关配置(比如对mvc的配置,对拦截器的配置等)
> 2. springboot源码(比如自动装配原理)
> 3. 一些与springboot集成的方法(比如springboot日志框架的替换或使用)

##SpringCloud相关

##服务端开发的一些理论知识

# 关系型数据库及框架

##SQL通用知识

> 1. sql语法
> 2. 调优
> 3. 使用技巧
> 4. 锁的使用

### ※数据表设计思路

定义类别表->定义表->定义对应实体表

在数据库设计中,切记一层一层的寻找对应关系

什么意思呢?

就比如打分定义表与报告表的关系

一个报告包含多个打分指标(非打分指标定义),一个打分指标对应一个分数(一一对应的就可以是一张表)!

而一个打分指标定义对应多个打分指标,此时打分指标这个表就相当于被两个表一对多关联了,所以自然而然的就成了这两个表的中间表!

"xx定义表"的价值就像是一个类,而定义表对应的"实例化表"就相当于一个对象,"xx定义表"的意义在于可以将"实例化表"的一些公有属性进行抽象,并实现配置化的功能。想要配置化,一定要引入定义表。

总结,像是每个页面都会都会出现的内容,其实都可以抽象一个定义表,然后配置化相关内容。甚至是每个循环列表项,每个下拉菜单,都有抽象成一个定义表的可能!

定义表是无状态的,不会存某个用户特有的数据,定义表对应的实例化表才是存特定数据的地方。一般而言,定义表是一对多的一!

像是考卷的试题,就可以有试题定义表,试题定义表的实例化表,就会存,张三的某个试题得了多少分!如果试题业务场景每人只用回答一道题,那大体的设计思路,也是这样的!



------



返过来想一想,如果没有定义表,就以试题为例,业务场景中每个用户需要回答多个试题。

如果我们不存在试题定义表,那么存储的的形式符合三大范式吗?

以张三为例,张三需要存储每个题都需要存储标题等信息,而大量的重复这些不变的信息,我们就需要警觉了。这样的设计就不符合第二范式了。**非主属性完全依赖于主键**。

 



------





自己做的Excel中,其实应该两个领域对象,两个领域对象的分析,先分析用户题目表,因为用户去做题,然后才会有得分,分析的思路是将用户与题目表该有的所有元素写在同一张表中,然后套3大范式,发现不符合第二范式,修正后形成中间表。

然后,根据业务分析,得分与用于和题目都有关系,所以直接扔到一个与用户和题目都有关系的那张中间表就行了!很简单吧

**模式就是关联两两进行设计(两个表所有信息合在一起就行),然后套3范式,主要是1与2范式,主要是第二范式,消除联合主键,遗忘了就想想本次评价的相关设计套路!**

一个引子

以本次的上传与打分定义为例子。首先一个报告包含多个附件定义,所以将这两个表的字段写在一起,多写两条数据后就会发现联合主键的问题,需要一个中间表。同样的一个报告也包含多个打分定义,依旧存在联合主键的问题,需要中间表,消除联合主键。

最后就是打分定义表与附件上传表,其实根据项目经理提供的"工作底稿"我们将这两个表的字段放在一起后发现会有联合主键的问题,所以依旧需要消除联合主键,引入第三张表。

最后就是打分的分支问题,根据业务场景,分值与报告和打分定义都有关系,毕竟一个确定的分支是由一个确定的报告和报告中某一个确定的打分定义项来的,所以既然都有关系,肯定也是存在中间表中,刚好有一个报告打分中间表,所以自然而然的就存在了"报告-打分定义中间表"中了。

------

上面我们学会了,去设计多对多的表,那如果甄选一对多呢?

很简单还是写在一起,如果发现不同的主键对应相同的某个,或某几个数据列,而这几个数据列的主键是相同的,那就是一对多的关系。

###命名问题

一定不要再命名成 r_id 之类的字段了!!!太坑了,因为自动生成domain的时候,会因为生成setter方法与getter方法导致入库出现问题!!!而且很难排错,所以**解决方案为,不写再图省事写x_id这样的代码了,不光是主键字段!**

在mysql中有很多保留字段,比如desc,一点字段叫作desc就会报sql异常的错误,大体上错误如下:

```sql
'desc,xx,xx)values(?,?,?)'
```

**根据最近的观察,数据库所有表的主键名固定为id,非常合理,编写代码的时候会处理起来思路会很清晰!**

###spring data jpa上的注意点

1. 一定要看报错信息,主要看最后一些报错!因为这几次出问题都是看最后的报错信息才改正的。
2. 在domain中设置集合的时候,一定不要用集合框架的实现类进行接收,需要用List或Set进行接收

###当一个表可能存不同类型的数据时

曲江项目就存在这样一个问题。

我们的报告表本来是存储"曲江评价报告"的,但是业务后期突然让加了一个"公共信用等级评价",这个数据最终因为查询列表的问题,也放在了报告表中

如此一来,我们就需要一个type字段来区分这两张表,等到项目上线的时候,发生了一个意想不到的问题。那就是我们查询"曲江报告用的是字段1",但是老数据的曲江报告type字段为null(毕竟以前没有这个字段么)。这就导致老数据查询出现问题,幸亏数据量不大,把type为null的字段通过where全部修改了!

**但是也为我涨了波教训,以后在设计表的时候,有可能一张表存两种相关的数据时,一定要在一开始就加入type字段,从而保证面对未来的扩展也留有一定的能力!**

###※数据库关联查询注意事项

本次不谈语法,只谈在关系型数据库中,链表查询的注意事项

我们在关联查询的时候,关联条件一般是 a.主键 = b.外键或反过来。

**切记注意不要观察两张表,有一样的字段就直接进行关联查询,因为很有可能这两张表有关联的字段其实根本不能作为多表查询的条件。如果关联条件不正确一定不能查询到我们想要的结果,最好的情况查询结果是null,要不然查询出来的就是脏数据!**

在严格遵守以上条件的情况下,如果存在a.非主键但唯一的字段 = b.主键,或反过来。

这种情况其实就是一对一的查询

如果是a.非主键但唯一的字段 = b.非主键但唯一的字段,且这两个字段是代表同一个东西,比如流程引擎中的businessKey与业务表中的主键,这样子也能作为关联条件进行查询,其实还是一对一,只不过没有明确外键主键关联关系。

###※事务与锁的案例

在当前章节案例中,session01是当前会话。session02是其他会话。

####简单案例

首先我们开启两个会话

我们将事务修改为手动提交

然后在session01中修改某条数据,在session02中同样对这条数据进行修改,我们可以发现,session02中的修改被阻塞了。相当于形成了行锁(innodb与正确使用索引时)。session02的日志如下![1566345547956](./assets/1566345547956.png)耗时40多秒,很明显被阻塞执行了,否则这么小的数据量,没有网络影响的情况下,不可能执行这么久!

如果索引使用不当,会导致行锁变表锁的!

####关于for update的使用

首先阅读这两个文档![1566349713207](./assets/1566349713207.png)案例如下

我们现在需要保证查询某项数据时,将结果集锁住,防止因为并发出现的超卖现象,做法为:![1566349790821](./assets/1566349790821.png)在session01中执行`select * from mmall_cart where id=126 for update`,然后在session02中执行![1566349861272](./assets/1566349861272.png)所以根据上面的现象,我们可以得知,阻塞只发生在,都在竞争某一个相同的锁时,才会阻塞,等待获取锁。如果语句无需锁就能执行,那就不会被阻塞!就像session02中`SELECT * FROM mmall_cart WHERE id=126`的执行无需锁,所以即使session01中使用的排它锁,锁住了id=126的结果集,在session02中依旧可以直接查询到当前结果集(已提交的事务,没有脏读现象)。因为`SELECT * FROM mmall_cart WHERE id=126`压根就不会去竞争锁,所以不会被阻塞执行!!!这点的坑也是想了很久才爬出来的!!!

##MySQL

## Mybatis

> 1. 生成器使用
> 2. 框架功能(比如如果反写主键)

# 非关系型数据库及框架

## Redis

> 1. redis主从配置
> 2. redis使用技巧
> 3. redis功能方向
> 4. redis使用思想